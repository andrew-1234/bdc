---
title: "Taxonomy"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Taxonomy}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, eval = FALSE)
devtools::load_all()
```


### Introduction
The combination of large datasets from several sources requires careful standardization of hundreds of taxon names. The taxonomic standardization process borrows heavily from Norman et al. (2020; *taxadb* package), which contains functions that allow querying millions of taxonomic names in a fast, automatable, and consistent way using high-quality locally stored taxonomic databases.

The workflow tools used to standardize names (*bdc_clean_name* and *bdc_query_names_taxadb*) contains additions to the *taxadb* package, including tools for:
- 1. Clean and parse scientific names;
- 2. Resolve misspelled names or variant spellings using a fuzzy matching application;
- 3. Convert nomenclatural synonyms to current accepted name;
- 4. Flag ambiguous results.

The taxonomic standardization is based on one taxonomic database chosen by the user. *taxadb* makes available the following taxonomic sources:

| Abbreviation | Taxonomic database                                        |
|--------------|-----------------------------------------------------------|
| col          | Catalogue of Life                                         |
| fb           | FishBase                                                  |
| itis         | Integrated Taxonomic Information System                   |
| iucn         | International Union for Conservation of Natureâ€™s Red List |
| gbif         | Global Biodiversity Information Facility                  |
| ncbi         | National Center for Biotechnology Information             |
| ott          | OpenTree Taxonomy                                         |
| tpl          | The Plant List                                            |
| slb          | SeaLifeBase                                               |
| wd           | Wikidata                                                  |


Details on taxonomic references and schema used in taxadb can be found in [Norman et al. (2020)](docs.ropensci.org/taxadb/articles/data-sources.html).


### Installation

You can install the released version of 'BDC' from [github](https://github.com/brunobrr/bdc) with:

```{r, message=FALSE, warning=FALSE}
if (!require("remotes")) install.packages("remotes")
if (!require("bdc")) remotes::install_github("brunobrr/bdc")
```

Creating folders to save the results
```{r}
bdc::bdc_create_dir()
```


### Read the database
Read the database created in the step **Pre-filter** of the BDC workflow. It is also possible to read any datasets containing the *required* fields to run the workflow (see the vignette "Standardization and integration of different datasets").

```{r}
database <-
  system.file("extdata",
              "Output",
              "Intermediate/01_prefilter_database.qs", package = "bdc") %>%
  readr::read_csv(database)

head(database)
```


Standardization of character encoding
```{r}
for (i in 1:ncol(database)){
  if(is.character(database[,i])){
    Encoding(database[,i]) <- "UTF-8"
  }
}
```


### Clean and parse species names
Scientific names improperly formatted usually cannot be matched with a valid names. To solve this issue, we developed the *bdc_clean_name.* containing functionalities to optimize the taxonomic queries by increasing the probability of finding matching names. This tool is used to remove:

1. Family names pre-pended to species names;
2. Qualifiers denoting uncertain or provisional status of taxonomic identification (e.g., confer, species, affinis, and among others);
3. Infraspecific terms (e.g., variety [var.], subspecies [subsp], forma [f.], and their spelling variations);
4. Standardize names, i.e., capitalize only the first letter of the genus name and remove extra whitespaces);
5. Parse names, i.e., separate author, date, annotations from taxon name.

```{r}
parse_names <- bdc_clean_names(sci_names = database$scientificName)
```


### Names harmonization
The taxonomic harmonization is based upon **one** of those taxonomic authorities previously mentioned.

```{r}
query_names <- bdc_query_names_taxadb(
  sci_name = database$names_clean,
  replace_synonyms = TRUE,
  suggest_names = TRUE,
  suggestion_distance = 0.9,
  db = "gbif",
  rank_name = "Plantae",
  rank = "kingdom",
  parallel = TRUE,
  ncores = 2,
  export_accepted = FALSE
)
```


Merge results of the taxonomy harmonization process with the original database. Before, let's rename the column containing the original scientific names to "verbatim_scientificName". From now on "scientifiName" correspond to the verified names (resulted from the name harmonization process). As the column "original_search" in "query_names" and "names_clean" are equal, only the first will be kept.

```{r}
database <-
  database %>%
  dplyr::rename(verbatim_scientificName = scientificName) %>%
  dplyr::select(-names_clean) %>%
  dplyr::bind_cols(., query_names)
```


### Report
The report is based on the column "notes" containing the results of the name standardization process.

```{r}
report <-
  bdc_create_report(data = check_pf,
                    database_id = "database_id",
                    workflow_step = "taxonomy")

report
```


### Unresolved names
It also possible filter out records with taxonomic status different of "accepted". Such records can be potentially resolved manually.

```{r}
unresolved_names <-
  bdc_filter_out_names(data = database,
                       taxonomic_notes = "accepted",
                       opposite = TRUE)
```

Save the table containing unresolved names
```{r}
unresolved_names %>%
 data.table::fwrite(., here::here("Output", "Check", "02_unresolved_names.csv"))
```


### Filter the database
It is possible to remove records with unresolved or invalid names to get a 'clean' database . However, to ensure that all records be evaluated in all the data quality tests (i.e., tests of the taxonomic, spatial, and temporal steps of the workflow), potentially erroneous or suspect records will be removed in the final step of the workflow.
```{r}
# output <-
#   bdc_filter_out_names(
#     data = database,
#     taxonomic_notes = "accepted",
#     opposite = FALSE
#   )
```


### Save the database

```{r}
database %>%
  qs::qsave(.,
            here::here("Output", "Intermediate", "01_prefilter_database.qs"))
```


